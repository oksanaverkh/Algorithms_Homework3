import org.w3c.dom.Node;

public class LinList {

    /**
     * Задание 1 (тайминг 5 минут)
     * 1.Реализуем простой односвязный список.
     * 2.Пишем только структуру, никаких методов не требуется.
     */

    private Node head;

    public void print() {
        if (head == null) {
            System.out.println("Empty list");
            return;
        }
        Node node = head;
        while (node != null) {
            System.out.print(node.value + " ->");
            node = node.next;
        }
    }

    private class Node {
        private int value;
        private Node next;
    }

    // Задание 2 (тайминг 10 минут)
    // 1.Реализуем метод добавления новых элементов в начало списка и удаление
    // первого элемента связного списка.
    // 2.Односвязный список всегда имеет ссылку на первый элемент
    // последовательности, потому именно с реализации методов для первого
    // элемента последовательности стоит начать

    public void addFirst(int value) {
        Node node = new Node();
        node.value = value;
        if (head != null) {
            node.next = head;
        }
        head = node;
    }

    public void removeFirst() {
        if (head == null) {
            System.out.println("ERROR!!");
        } else {
            head = head.next;
        }
    }

    // Задание 4 (тайминг 10 минут)
    // 1.Реализуем метод добавления новых элементов в конец списка и удаление
    // последнего элемента связного списка.
    // 2.Теперь, когда мы понимаем, как можно искать значения внутри связного
    // списка,
    // мы можем сделать методы добавления и удаления элементов в конец нашего
    // односвязного списка.

    public void addLast(int value) {
        Node node = new Node();
        node.value = value;
        if (head == null) {
            head = node;
        } else {
            Node last = head;
            while (last.next != null) {
                last = last.next;
            }
            last.next = node;

        }
    }

    public void removeLast() {
        if (head == null) {
            System.out.println("ERROR!!");
        } else {
            Node node = head;
            while (node.next != null) {
                if (node.next.next == null) {
                    node.next = null;
                    return;
                }
                node = node.next;
            }
            head = null;
        }
    }

    // Задание 3 (тайминг 10 минут)
    // 1.Реализуем метод поиска элемента в односвязном списке для проверки наличия
    // элемента внутри списка.
    // 2.Для корректной работы со связным список необходимо понимать, как именно
    // можно обходить все значения внутри связного списка.
    // 3.Для нашего примера проще всего будет написать метод поиска значения в
    // связном списке и возвращения из метода информации о наличии искомого
    // внутри списка.

    public boolean contains(int value) {
        Node node = head;
        int index = 0;
        while (node != null) {
            if (node.value == value) {
                System.out.println("Index of the element = " + index);
                return true;
            }
            node = node.next;
            index++;

        }
        return false;
    }

    // Задание 5 (тайминг 5 минут)
    // 1.Расширяем структуру связного списка до двухсвязного.
    // 2.Мы научились работать с односвязным список, теперь можно ближе
    // познакомиться со структурой двухсвязного списка и особенностей его
    // внутреннего строения.
    // 3.Стоит напомнить, что двухсвязный список представляет из себя цепочку
    // элементов, которые умеют ссылаться не только на следующий элемент
    // последовательности, но и на предыдущий.
    // 4.Вносить корректировки в уже готовые методы на текущий момент не стоит, их
    // модификацией мы займемся позднее

    // Задание 6 (тайминг 10 минут)
    // 1.Обновляем методы согласно новой структуре.
    // 2.Появилась дополнительная переменная, которую необходимо отслеживать во
    // всех операциях.
    // 3.Так же благодаря ссылке на последний элемент списка операции работы с
    // концом стали проще и их стоит заменить на логику аналогичную работе с
    // началом списка

    // Задание 7 (тайминг 15 минут)
    // 1.Добавляем метод сортировки для связного списка.
    // 2.Можно использовать любой алгоритм, что мы использовали на предыдущем
    // семинаре, но с точки зрения работы связного списка лучше ориентироваться на
    // пузырьковую сортировку, т.к. она взаимодействует с соседними элементами, а
    // не только по индексам, как делают все остальные сортировки.

}
